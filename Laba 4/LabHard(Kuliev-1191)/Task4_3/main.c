//----------------------------------------------------------------------------------------------------------------------------------------
//Проект: "Программный отладчик".
//Назначение программы: добавление в код программы функции для приостановки ее выполнения, и вывода текущих значений переменных тестируемой программы.
//Разработчик: Кулиев Эмир Шамсаддинович - 1191б
//Цель: создание функции, которая добавляется в код тестируемой программы для приостановки ее выполнения, 
//			реагирует на команды удаленного терминала и позволяет отображать в нем текущие значения переменных тестируемой программы 
//Решаемые задачи:
//		1. Реализация функции-обработчика внутреннего прерывания микроконтроллера STM32F072RBT (USART);
//		2. Конфигурирование NVIC;
//		3. Создание функции, приостанавливающий пргорамму и выодящей текущие значения переменных.
//----------------------------------------------------------------------------------------------------------------------------------------

#include "main.h"																							
																															
static  int32_t counter;																			// Счетчик итераций для вывода в терминал
static	int32_t a = 7;																				// Начальное значение члена геометрической прогрессии
static	int32_t quotient = -5;																// Переменная коэфициента для геометрической прогрессии
static	int32_t sum = 7;																			// Начальное значение суммы членов прогрессии
static uint8_t flag;																					// Флаг для проверки нажатой кнопки
static uint8_t flagF = 0;																			// Флаг для проверки нажатия F5
																															
int main()																										
{																															
	__disable_irq();																						// Глобальное запрещение прерываний
																															// Настройка порта GPIOB для контроля светодиода
	RCC->AHBENR|=RCC_AHBENR_GPIOBEN;														// Включение тактирования порта В
	GPIOB->MODER|= GPIO_MODER_MODER0_0 | GPIO_MODER_MODER8_0; 	// Переключение линий 0 и 8 порта В в режим "Output"
	GPIOB->MODER&=~ (GPIO_MODER_MODER12 | GPIO_MODER_MODER13);	// Переключение линий 12(SW4) и 13(SW3) порта В в режим "Input"
	GPIOB->ODR|=0x100;																					// Разрешение работы светодиодов на стенде CТМ_01 с помощью установки логической "1" на выводе РВ.8									
																															
	InitUSART1();																								// Инициализация модуля USART1
	NVIC->ISER[0] |= 0x08000000; 																// Разрешение в NVIC прерывания от модуля USART1 	
	__enable_irq();																							// Глобальное разрешение прерываний 
	while(1){																										
		for (int32_t i = 1; i <=14; i++){													// Счетчик для итераций
			counter = i;																						// Приравнивание глобальной переменной к локальной перменной цикла
			a = geometric_progressive(a, quotient, i);							// Выполнение одной итерации геометррической прогрессии
			if (i == 1){																						// Если это первая итерация
				sum = a;																							// Сумма не изменяется
			} else {																					
				sum = sum + a;																				// Сложение членов прогрессии 
			}
			debug();																								// Вызов функции отладчика
			if (i == 14){																						// Когда цикл закончивается, значения для текущего члена и суммы членов прогрессии устанавливаются в значения по умолчанию
				a = 7;																							
				sum = 7;																						
			}																												
		}																													
	}																														
}								
// Функция инициализации USART лабораторного комплекса STM0_1. 
void InitUSART1(void)																					                                                                                                 
{																															  																																																																												    
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;												// Включение тактирования USART1. RCC_APB2ENR_USARRT1EN=0x00004000.                                                                                             
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;													// Включение тактирования порта A. RCC_AHBENR_GPIOAAEN=0x00020000.                                                                                              
																															// Настройка линий порта A: PA9(TX_1) - выход передатчика; PA10 (RX_1) - вход приемника.                                                                        
	GPIOA->MODER |= 0x00280000;																	// Перевести линии PA.9 и PA.10 в режим альтернативной функции.                                                                                                 
	GPIOA->AFR[1] |= 0x00000110;																// Включить на линиях PA.9 и PA.10 альтернативнуж функцию AF1.                                                                                                  
																															// Настройка линии передатчика Tx (PA.9).                                                                                                                       
	GPIOA->OTYPER &= ~GPIO_OTYPER_OT_9;													// Сбросить 9 бит GPIOA->OTYPER - переключение в режим push-pull для линии PA.9 (активный выход).                                                               
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR9;													// Отключение подтягивающих резисторов для линии PA.9.                                                                                                          
	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEEDR9;										// Установка высокой скорости синхронизации для линии PA.10.                                                                                                    
																															// Настрйока линии приемника Rx (PA.10).                                                                                                                        
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR10;												// Сброс режима подтягивающих резисторов для линии PA.9.                                                                                                        
	GPIOA->PUPDR |= GPIO_PUPDR_PUPDR10_0;												// Включение подтягивающего резистора pull-up на входной линии PA.10 (вход приемника Rx)                                                                        
																															// Конфигурирование USART.                                                                                                                                      
	USART1->CR1 &= ~USART_CR1_UE;																// Запрещение работы модуля USART1 для изменения параметров его конфигруации.                                                                                   
	USART1->BRR = 69;																						// Настройка делителя частоты тактирующего USART и задающего скорость приема и передачи данных на уровне 115200 бит/с: Частота тактирующего генератора = 8 МГц; 
																															// Скорость обмена по USART = 115200 бит/с; коэффициент деления = 8000000 / 115200 = 69,4444(4); Округленное значение = 69.                                     
	USART1->CR1 = USART_CR1_TE | USART_CR1_RE;									// Разрешить работу приемника и передатчика USART. Остальные биты этого регистра сброшены, что обесипечивает: количество бит данных в пакете = 8;               
																															// контроль четности - отключен; прерывания по любым флагам USART - запрещены; состояние USART - отключен.                                                      
	USART1->CR1 |= USART_CR1_RXNEIE | USART_CR1_TCIE;						// Разрешение на выдачу сигнала прерывания при возникновении событий: прием кадра в буферный регист; завершение передачи кадра. 
	USART1->CR2 = 0;																						// Количетсво стоп-бит - 1.                                                                                                                                     
	USART1->CR3 = 0;																						// DMA1 - отключен                                                                                                                                              
	USART1->CR1 |= USART_CR1_UE;																// По завершении конфигурирования USART разрешить его работу (биту UE регистра CR1 присвоить 1).                                                                
}																															
																															
// Функция отладчик
void debug(){																									// Функция отладчик
	while(1){																										
		if(flag == 1){																						// Если нажата F5
			flag = 0;																								
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					// Переход на новую строку со сдвигом каретки 
			USART1->TDR = 0x0D;																			
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						
			USART1->TDR = 0x0A;																			
			break;																									// Выход из цикла = завершение функции
		}																													
		if(flag == 2){																						// Если нажат i
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						
			USART1->TDR = 0x6E;																			
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					// Вывод сообщения "n=%номер_итерации%"
			USART1->TDR = 0x3D;																			
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						
			numToArray(counter);																		
			flag = 0;																								// Флаг нажатой кнопки принимает стандартное значение 0
		}																													
		if(flag == 3){																						// Если нажата e
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						
			USART1->TDR = 0x41;																			
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						
			USART1->TDR = 0x6E;																			// Вывод сообщения "an=%текущее_значение_переменной%"
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						
			USART1->TDR = 0x3D;																				
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						
			numToArray(a);																					
			flag = 0;																								// Флаг нажатой кнопки принимает стандартное значение 0
		}																													
		if(flag == 4){																						// Если нажата s
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						
			USART1->TDR = 0x73;																			
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					// Вывод сообщения "s=%сумма_членов_прогрессии""
			USART1->TDR = 0x3D;																			
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						
			numToArray(sum);																				
			flag = 0;																								// Флаг нажатой кнопки принимает стандартное значение 0
		}																													
	}																														
}																															
// Функция обработчик прерываний.																						
void USART1_IRQHandler(void)																	
{																															
	uint16_t pack;																							
																															// Событие готовности принятых данных к чтению 
	if (USART1->ISR & USART_ISR_RXNE) { 												// Если в регистре состояний USART1 установлен флаг "RXNE", то
		pack=(uint8_t)USART1->RDR; 																// Чтение принятого битового пакета из буферного регистра приемника USART1 
		switch ( pack ) {																					
		case 0x69:																								// Если нажата клавиша i
			flag = 2;																								// Флаг flag принимает значение 2
			flagF = 0;																							// Флаг flagF принимает значение 0 
			break;																									
		case 0x65:																								// Если нажата клавиша e
			flag = 3;																								// флаг flag принимает значение 3
			flagF = 0;																							// флаг flagF принимает значение 0 
			break;																									
		case 0x73:																								// Если нажата клавиша s
			flag = 4;																								// флаг flag принимает значение 4
			flagF = 0;																							// флаг flagF принимает значение 0 
			break;																									
// Начало обработки нажатия на F5
		case 27:																									// Если принят пакет 027
			flagF = 1;																							// флаг flagF принимает значение 1
			break;																									
		case 91:																									// Если вторым принят пакет 091
			if (flagF == 1){																				// Если флаг flagF в значении 1
				flagF = 2;																						// flagF принимает значение 2
			}																													
			break;																									
		case 49:																									// Если третьим принят пакет 049
			if (flagF == 2){																				// Если флаг flagF в значении 2
				flagF = 3;																						// flagF принимает значение 3
			}																												
			break;																									
		case 53:																									// Если четвертым принят пакет 053
			if (flagF == 3){																				// Если флаг flagF в значении 3
				flagF = 4;																						// flagF принимает значение 4
			}																												
			break;																									
		case 126:																									// Если пятым принят пакет 126
			if (flagF == 4){																				// Если флаг flagF в значении 4
				flagF = 0;																						// flagF принимает стандартное значение 0
				flag = 1;																							// флаг flag принимает значение 1, что соответсвует нажатой f5
			}																												
			break;																									
		default:																									
			flagF = 0;																							// Если приянт любой другой пакет, то flagF становится в начальное положение
			break;																									
		}																													
																															// Конец обработки нажатия на F5
	}																														
	
																															// Событие завершение передачи битового пакета 
	if (USART1->ISR & USART_ISR_TC) {														// Если в регистре состояний USART1 установлен флаг "ТС", то
																															// Сброс флага завершения передачи кадра 
		USART1->ICR=USART_ICR_TCCF;																// Сбросить флаг завершения передачи кадра, чтобы прерывание не сработало повторно
	}																														
}																															

// Функция расчета геометрической прогресии
int32_t geometric_progressive(int32_t an, int32_t q, int32_t n){
	if (n == 1){																								// Если итерация первая возвращается первый член прогрессии
		return an;																								
	}																													
	else{																												// Иначе просиходит умножение коэффициента на переменную
		return q*an;																							
	}																														
}																															
																															
void numToArray(int32_t num){																	// Функция вывода числа в терминал PuTTY
	int32_t count = 0;																					// Переменная, отвечающая за размер числа 
	int32_t n = 10;																							// Переменная, для определения размера числа
	int32_t temp;																								// Временная переменная
																															
	if (num < 0){																								// Если число отрицательное
		num = num * (-1);																					// То число умножаем на -1
		while ((USART1->ISR & USART_ISR_TXE) == 0) {}							
		USART1->TDR = 0x2d;  																			// И выводим перед выводом числа знак минус				
	}																														
	while (num!=0){																							// Пока число не равное 0
		if (num > n){																							// Получаем размер числа, пока num больше числа
			n *= 10;																								// Увеличиваем n на 1 порядок
			count +=1;																							// Увеличиваем переменную размера числа,
		}																													
		else {																										// Как только переменная стала больше числа,
			n /= 10;																								// Уменьшаем n на 1 порядок
			count -=1;																							// Уменьшаем переменную размера числа.
			temp = num % n;																					// Временная переменная приравнивается остатку от деления числа на n
			while ((USART1->ISR & USART_ISR_TXE) == 0) {}							
			USART1->TDR = (uint16_t) ((num-temp)/n) + 48;						// В терминал подается пакет, соответвующий цифре текущего разряда. В качестве примера: ((3514-514)/1000) + 48 - в терминал будет выведено 3
			num = temp;																							// Уменьшаем количество разрядов в числе, присваивая переменной числа значение временной переменной
		}																													
	}																														
	while ((USART1->ISR & USART_ISR_TXE) == 0) {}								// Переход на новую строку со сдвигом каретки
	USART1->TDR = 0xd;																					
	while ((USART1->ISR & USART_ISR_TXE) == 0) {}								
	USART1->TDR = 0xa;																					
}																															
//----------------------------------------------------------------------------------------------------------------------------------------
//Руководство пользователя:
//		1. Запустите программу на лабораторном комплексе;
//		2. На компьютере запустите приложение PuTTY и подключитесь к соответствующему COM-порту на скорости 115200 бит/с;
// 		3. При активном окне терминала нажмите: 'i' для вывода текущей итерации;
//																						's' для вывода суммы членов прогрессии до текущей итерации;
//																						'e'	для вывода текущего члена прогресии;
//																						'f5' для переключения на следующую итерацию.
//----------------------------------------------------------------------------------------------------------------------------------------
